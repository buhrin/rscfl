/**
 * Tracks scheduler function calls and updates resourceful data structures
 * accordingly
 *
 * To check: in principle, all scheduler functions will disable kernel
 * preemption, so we should be able to access the per-cpu variables direcly
 * without worrying that we'll be preempted.
 *
 * Never sleep or call operations that might block within any of the following
 * functions.
 */
%{
  #include "rscfl/kernel/sched.h"
%}

function _ctx_switch(next_tid:long) %{
  on_ctx_switch(STAP_ARG_next_tid);
%}

function _cpu_switch(from:long, to:long, pid:long) %{
  on_cpu_switch(STAP_ARG_from, STAP_ARG_to, STAP_ARG_pid);
%}

function _task_exit(pid:long) %{
  on_task_exit(STAP_ARG_pid);
%}

// available parameters @prev_pid, @prev_tid, @next_pid, @next_tid
probe rscfl.sched.ctxswitch = scheduler.ctxswitch {
  _ctx_switch(next_tid)
}

// available parameters: @cpu_from, @cpu_to, @pid
probe rscfl.sched.migrate = scheduler.migrate {
  _cpu_switch(cpu_from, cpu_to, pid)
}

// available parameters: @pid, @priority
probe rscfl.sched.task_exit = kernel.function("do_exit") {
  if (@defined($tsk)) {
    __tsk = $tsk
    pid = $tsk->pid
  }
  else {
    __tsk = task_current()
    pid = @cast(__tsk, "task_struct",
          "kernel<linux/sched.h>")->pid
  }
  _task_exit(pid)
}
