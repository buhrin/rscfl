#!/usr/bin/stap -g

%{

#include "costs.h"
#include "res_kernel/stap_shim.h"
#include "res_kernel/res_comm.h"
#include "res_kernel/probes.h"

%}

global cycles = 0
global wall_clock_time
global probe_nest = 0;

probe begin
{
  if (probes_start()) {
    print("rscfl: unable to initialise");
    exit();
  }
  print("running");
}

probe end
{
  if (probes_end()) {
    print("rscfl: unable to cleanup");
    exit();
  }
}

function probes_start:long()
%{
  STAP_RETVALUE = probes_init();
%}

function probes_end()
%{
  STAP_RETVALUE = probes_cleanup();
%}

function should_acct_:long(pid:long, syscall_nr:long)
%{
  acct = _should_acct(STAP_ARG_pid, STAP_ARG_syscall_nr);
  STAP_RETVALUE = (acct != NULL);
%}

function should_acct()
{
  return should_acct_(pid(), -1);
}

function fill_struct(vfs:long, wall_clock_time:long, fill_type:long)
%{
  debugk("Nest %lld\n", global(s_probe_nest));
  _fill_struct(STAP_ARG_vfs, STAP_ARG_wall_clock_time, acct, STAP_ARG_fill_type);
%}

function clear_acct_next(pid:long, syscall_nr:long)
%{
  acct = NULL;
  _clear_acct_next(STAP_ARG_pid, STAP_ARG_syscall_nr);
%}

function acct_now:long()
%{
  STAP_RETVALUE = (acct != NULL);
%}

probe kernel.function("sys_accept").call
{
  %{printk("Sys_accept cl\n")%}
  start = gettimeofday_us()
  if(should_acct()) {
    probe_nest++;
    cycles = get_cycles();
    wall_clock_time = start;
  }
}

probe kernel.function("sys_accept").return
{
  if (acct_now()) {
    fill_struct(get_cycles() - cycles, gettimeofday_us() - wall_clock_time,
    %{FILL_NET%});
    probe_nest -= 1;
    if(probe_nest == 0){
      clear_acct_next(pid(), -1);
    }
  }
}

/*
* PROBES: sendfile
*/

/* FS */
probe kernel.function("sys_sendfile").call
{
  %{printk("Sys_sendfile cl\n")%}
  start = gettimeofday_us()
  if (should_acct()) {
    probe_nest++;
    cycles = get_cycles()
    wall_clock_time = start
  }
}

probe kernel.function("sys_sendfile").return
{
  if (acct_now()) {
    fill_struct(get_cycles() - cycles, gettimeofday_us() - wall_clock_time,
    %{FILL_FS%})
    probe_nest -= 1;
    if(probe_nest == 0){
      clear_acct_next(pid(), -1);
    }
  }
}

/* MM */
probe kernel.function("__kmalloc").call
{
  %{printk("__kmalloc cl\n")%}
  start = gettimeofday_us()
  if (should_acct()) {
    probe_nest++;
    cycles = get_cycles()
    wall_clock_time = start;
  }
}

probe kernel.function("__kmalloc").return
{
  if (acct_now()) {
    fill_struct(get_cycles() - cycles, gettimeofday_us() - wall_clock_time,
    %{FILL_MM%})
    probe_nest -= 1;
    if(probe_nest == 0){
      clear_acct_next(pid(), -1);
    }
  }
}

/* NET */
probe kernel.function("sock_sendpage").call
{
  %{printk("Sock_sendpage cl\n")%}
  start = gettimeofday_us()
  if (should_acct()) {
    probe_nest++;
    cycles = get_cycles()
    wall_clock_time = start
  }
}

probe kernel.function("sock_sendpage").return
{
  if (acct_now()) {
    fill_struct(get_cycles() - cycles, gettimeofday_us() - wall_clock_time,
    %{FILL_NET%})
    probe_nest -= 1;
    if(probe_nest == 0){
      clear_acct_next(pid(), -1);
    }
  }
}
