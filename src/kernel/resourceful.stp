#!/usr/bin/stap -g

%{

#include "costs.h"
#include "res_kernel/stap_shim.h"
#include "res_kernel/res_comm.h"

%}

global files_dir=0, vfs=0, lfs=0, blk=0
global files_dir_e=0, vfs_e=0, blk_e=0, cycles=0

probe begin
{
  if (create_shared_mem()) {
    printf("Unable to create debugfs entry\n");
    exit();
  }
  if (netlink_setup()) {
    printf("Cannot setup netlink\n");
    exit();
  }
  print("running");
}

probe end
{
  clean_debugfs();
  if (netlink_teardown()) {
    printf("Cannot teardown netlink\n");
  }
}

function netlink_setup:long()
%{
  STAP_RETVALUE = _netlink_setup();
%}

function clean_debugfs()
%{
  _clean_debugfs();
%}

function netlink_teardown:long()
%{
  STAP_RETVALUE = _netlink_teardown();
%}

function create_shared_mem:long()
%{
  STAP_RETVALUE = _create_shared_mem();
%}

function should_acct_:long(pid:long, syscall_nr:long)
%{
  STAP_RETVALUE = _should_acct(STAP_ARG_pid, STAP_ARG_syscall_nr);
%}

function should_acct()
{
  return should_acct_(pid(), -1);
}


function fill_struct(vfs:long)
%{
  _fill_struct(STAP_ARG_vfs);
%}

function update_relay()
%{
  _update_relay();
%}

function clear_acct_next(pid:long, syscall_nr:long)
%{
  _clear_acct_next(STAP_ARG_pid, STAP_ARG_syscall_nr);
%}


probe kernel.function("sys_socket").return
{
  if (should_acct()) {
    clear_acct_next(pid(), -1);
    fill_struct(get_cycles() - cycles);
    update_relay();
  }
}

probe kernel.function("sys_socket").call
{
  if (should_acct()) {
    files_dir = 0;
    vfs = 0;
    lfs = 0;
    blk = 0;
    files_dir_e = get_cycles();
    cycles = get_cycles();
  }
}

probe kernel.function("vfs_read").call
{
  if (should_acct()) {
    vfs_e = get_cycles();
  }
}

probe kernel.function("vfs_read").return
{
  if (should_acct()) {
    vfs += get_cycles() - vfs_e;
  }
}

#probe kernel.function("ext4_readpages").call
#{
# if (should_acct()) {
#   lfs_e = get_cycles();
#   blk = 0;
# }
#}

#probe kernel.function("ext4_readpages").return
#{
# if (should_acct()) {
#   lfs += get_cycles() - lfs_e;
# }
#
#}

probe kernel.function("blk_finish_plug").call
{
  if (should_acct()) {
    blk_e = get_cycles();
  }
}

probe kernel.function("blk_finish_plug").return
{
  if (should_acct()) {
    blk += get_cycles() - blk_e;
  }
}

