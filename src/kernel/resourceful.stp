#!/usr/bin/stap -g

%{

#include "costs.h"
#include "res_kernel/stap_shim.h"
#include "res_kernel/res_comm.h"
#include "res_kernel/probes.h"

struct accounting *acct;

%}

global cycles=0
global wall_clock_time

probe begin
{
  if (probes_start()) {
    print("rscfl: unable to initialise");
    exit();
  }
  print("running");
}

probe end
{
  if (probes_end()) {
    print("rscfl: unable to cleanup");
    exit();
  }
}

function probes_start:long()
%{
  STAP_RETVALUE = probes_init();
%}

function probes_end()
%{
  STAP_RETVALUE = probes_cleanup();
%}

function should_acct_:long(pid:long, syscall_nr:long)
%{
  acct = _should_acct(STAP_ARG_pid, STAP_ARG_syscall_nr);
  STAP_RETVALUE = (acct != NULL);
%}

function should_acct()
{
  return should_acct_(pid(), -1);
}


function fill_struct(vfs:long, wall_clock_time:long)
%{
  _fill_struct(STAP_ARG_vfs, STAP_ARG_wall_clock_time, acct);
%}

function clear_acct_next(pid:long, syscall_nr:long)
%{
  acct = NULL;
%}

function acct_now:long()
%{
  STAP_RETVALUE = (acct != NULL);
%}

probe kernel.function("sys_socket").return
{
  if (acct_now()) {
    fill_struct(get_cycles() - cycles, gettimeofday_us() - wall_clock_time);
    clear_acct_next(pid(), -1);
  }
}

probe kernel.function("sys_socket").call
{
  start = gettimeofday_us()
  if (should_acct()) {
    cycles = get_cycles();
    wall_clock_time = start;
  }
}

probe kernel.function("sys_accept").call
{
  start = gettimeofday_us()
  if(should_acct()) {
    cycles = get_cycles();
    wall_clock_time = start;
  }
}

probe kernel.function("sys_accept").return
{
  if (acct_now()) {
    fill_struct(get_cycles() - cycles, gettimeofday_us() - wall_clock_time);
    clear_acct_next(pid(), -1);
  }
}

/*
* PROBES: sendfile
*/

/* FS */
probe kernel.function("sys_sendfile").call
{
  start = gettimeofday_us()
  if (should_acct()) {
    cycles = get_cycles()
    wall_clock_time = start
  }
}

probe kernel.function("sys_sendfile").return
{
  if (acct_now()) {
    fill_struct(get_cycles() - cycles, gettimeofday_us() - wall_clock_time)
    clear_acct_next(pid(), -1);
  }
}

/* MM */
probe kernel.function("__kmalloc").call
{
  start = gettimeofday_us()
  if (should_acct()) {
    cycles = get_cycles()
    wall_clock_time = start;
  }
}

probe kernel.function("__kmalloc").return
{
  if (acct_now()) {
    fill_struct(get_cycles() - cycles, gettimeofday_us() - wall_clock_time)
  }
}

/* NET */
probe kernel.function("sock_sendpage").call
{
  start = gettimeofday_us()
  if (should_acct()) {
    cycles = get_cycles()
    wall_clock_time = start
  }
}

probe kernel.function("sock_sendpage").return
{
  if (acct_now()) {
    fill_struct(get_cycles() - cycles, gettimeofday_us() - wall_clock_time)
  }
}
